xlab="", ylab="",
ylim=c(0,0.65),
main= names(which(unlist(lapply(r.sq.vals, sum)) == sum(unlist(plot.data[[i]])))))
points(y=plot.data[[i]][interval], x=interval,
pch=20, cex=1.5)
abline(h=max(plot.data[[i]]), col="red", cex=1.25)
text(x=max(interval)-2,y=max(plot.data[[i]]),labels=round(max(plot.data[[i]]),2),pos=3,col="red")
if(i==1) mtext("R-squared", side=2, line=3, outer=FALSE)
# }))
}
# Plot rmse as a function of degree of diurnal model
plot.data <- list(rmse.vals[[1]], rmse.vals[[2]], rmse.vals[[3]], rmse.vals[[4]])
for(i in 1:length(plot.data)) {
interval <- 1:degrees
plot(y=plot.data[[i]][interval], x=interval,
# pch=20,
type = "l",
xlab="", ylab="",
ylim=c(0.65,0.95),
main= names(which(unlist(lapply(rmse.vals, sum)) == sum(unlist(plot.data[[i]])))))
points(y=plot.data[[i]][interval], x=interval,
pch=20, cex=1.5)
abline(h=min(plot.data[[i]]), col="red", cex=1.25)
text(x=max(interval)-2,y=min(plot.data[[i]]),labels=round(min(plot.data[[i]]),2),pos=3,col="red")
if(i==1) mtext("RSME", side=2, line=3, outer=FALSE)
# }))
}
mtext("Degree of Diurnal Model", side = 1, line = 1, outer=TRUE, adj=0.5)
# par(mfrow=c(1,4), mar=c(3, 1.5, 3, 1.5) + 0.1, oma=c(2,3.25,0,0), cex=0.9, family="serif")
par(mfrow=c(1,4), mar=c(2, 2, 2, 0) + 0.1, oma=c(3,3,0,0), cex=.9, family="serif")
for(i in 1:4) {
plot.range <- (nrow(real.data[[i]]) - min(sapply(obj.list, function(x) nrow(get(x))))):nrow(real.data[[i]])
plot(as.zoo(real.data[[i]][plot.range,"Z7 NH4"]), plot.type="multiple", main=names(real.data)[i],
xlab="", ylab="", ylim=c(0,10))
if(i==1) mtext("Zone 7 Ammonia (mg/L)", side = 2, line = 3, outer=FALSE, adj=0.5)
}
mtext("Date", side = 1, line = 1, outer=TRUE, adj=0.5)
# Add diurnal model predictors to dataset
for(x in obj.list) {
obj.x <- get(x)
# Convert timestamps to runtime and project onto a unit circle
t <- 1440
time.stamps <- difftime(index(obj.x), index(obj.x)[1], units = "mins")
time.stamps <- as.numeric(time.stamps) %% t # Cycles are constructed
time.stamps <- (time.stamps*360/t)*pi/180 # Cycles of minutes are converted to radians
names(time.stamps) <- "time.stamps"
cos.x <- cos(time.stamps)
names(cos.x) <- "cos.x"
sin.x <- sin(time.stamps)
names(sin.x) <- "sin.x"
cos.2x <- cos(2*time.stamps)
names(cos.2x) <- "cos.2x"
sin.2x <- sin(2*time.stamps)
names(sin.2x) <- "sin.2x"
cos.3x <- cos(3*time.stamps)
names(cos.3x) <- "cos.3x"
sin.3x <- sin(3*time.stamps)
names(sin.3x) <- "sin.3x"
cos.4x <- cos(4*time.stamps)
names(cos.4x) <- "cos.4x"
sin.4x <- sin(4*time.stamps)
names(sin.4x) <- "sin.4x"
cos.5x <- cos(5*time.stamps)
names(cos.5x) <- "cos.5x"
sin.5x <- sin(5*time.stamps)
names(sin.5x) <- "sin.5x"
cos.6x <- cos(6*time.stamps)
names(cos.6x) <- "cos.6x"
sin.6x <- sin(6*time.stamps)
names(sin.6x) <- "sin.6x"
assign(x, cbind(get(x), time.stamps, cos.x, sin.x, cos.2x, sin.2x,
cos.3x, sin.3x, cos.4x, sin.4x, cos.5x, sin.5x, cos.6x, sin.6x),
envir = .GlobalEnv)
}
library(glmnet)
start <- Sys.time()
for(obj in obj.list) {
obj.data <- get(obj)
predict.col <- which(colnames(obj.data) == "Z7.NH4")
if(paste0("all-days-",obj,".RData") %in% list.files(path="results/")) {
next
} else {
all.days <- list()
for(days in 1:6) {
# Days to train on
training.days <- days
training.obs <- training.days*24*60/5
total.obs <- nrow(obj.data)
testing.obs <- total.obs-training.obs
testing.days <- testing.obs/(24*60/5)
all.horizons <- list()
for(f in horizon.steps) {
# for(i in 1:(total.obs-2*f-training.obs+1)) { # Faster to do this in an lapply loop
testing.results <- do.call("rbind", lapply(1:(total.obs-2*f-training.obs+1), function(i) {
# What is the forecast horizon? (given in number of steps & number of minutes )
horizon.min <- seq(5,75,by=5)
horizon.steps <- horizon.min/5
# Setup training and testing data for model
current.obs <- training.obs+f+i-1
train.xx <- matrix(as.numeric(obj.data[i:(current.obs-f),]), nrow=length(i:(current.obs-f)), byrow=FALSE)
train.yy <- matrix(as.numeric(obj.data[(i+f):current.obs, predict.col]), nrow=length(i:(current.obs-f)), byrow=FALSE)
n <- intersect(which(!is.na(train.yy)), which(!apply(train.xx,1,anyNA)))
train.xx <- train.xx[n,]
train.yy <- train.yy[n,]
test.xx <- matrix(as.numeric(obj.data[current.obs,]), nrow=1, byrow=FALSE)
test.yy <- matrix(as.numeric(obj.data[(current.obs+f), predict.col]), nrow=1, byrow=FALSE)
test.index <- index(obj.data[current.obs,])
# Train diurnal model
diurnal.terms <- c(grep("cos", colnames(obj.data)), grep("sin", colnames(obj.data)))
mod.lm <- cv.glmnet(train.xx[,diurnal.terms],train.yy, alpha=0)
pred.lm <- predict(mod.lm, newx=train.xx[,diurnal.terms])
# Calculate training error
SSE <- mean((train.yy-pred.lm)^2)
SST <- mean((train.yy-mean(train.yy))^2)
Rsqu.lm <- 1-SSE/SST;Rsqu
RMSE.lm <- sqrt(SSE)
pred.lm <- predict(mod.lm, newx=t(test.xx[,diurnal.terms]))
# Train model when lambda=0 (initial parameter estimate)
mod.ridge <- cv.glmnet(train.xx,train.yy,alpha=0)
predict.mod.ridge <- predict(mod.ridge, newx=train.xx)
# # Plot training
# par(mar=c(3.5,3.5,1,10),xpd=TRUE, cex=0.9, family="serif")
# plot(train.yy,ylab="",xlab="", type="l", ylim=c(min(predict.mod.ridge),max(train.yy)))
# lines(predict.mod.ridge, col="red", lty=2)
# mtext(side=2, line=2.5, "Scaled Ammonia")
# mtext(side=1, line=2.5, "Observations (5 min interval)")
#
# legend("right",inset=c(-.5,0),
#        legend=c("Actual NH4","Linear Forecast\nw/ Sine Cosine"),
#        col=c("black","red"), lty=c(1,2) ,y.intersp=1.5)
# Adaptive lasso
w3 <- 1/abs(matrix(coef(mod.ridge, s=mod.ridge$lambda.min)[, 1][-1]))^1
set.seed(Sys.time())
mod.adaptive <- cv.glmnet(train.xx,train.yy,alpha=1,penalty.factor=w3)
pred.adapt <- predict(mod.adaptive,newx=train.xx, s='lambda.1se')
# Calculate training error
SSE <- mean((train.yy-pred.adapt)^2)
SST <- mean((train.yy-mean(train.yy))^2)
Rsqu.adapt <- 1-SSE/SST;Rsqu
RMSE.adapt <- sqrt(SSE)
SSE <- mean((train.yy-train.xx[,predict.col])^2)
Rsqu.persistence <- 1-SSE/SST;Rsqu
RMSE.persistence <- sqrt(SSE)
# Forecast
pred.adapt <- predict(mod.adaptive,newx=test.xx, s='lambda.1se')
pred.persistence <- test.xx[,predict.col]
# Save results
# if(i==1) {
testing.results <- data.frame("Test.time"= test.index,
"Actual.forecast" = as.numeric(test.yy),
"LM.forecast" = as.numeric(pred.adapt),
"Persistence.forecast" = as.numeric(pred.persistence),
"Training.R2.LM" = as.numeric(Rsqu.adapt),
"Training.RMSE.LM" = as.numeric(RMSE.adapt),
"Diurnal.forecast" =as.numeric(pred.lm),
"Training.R2.D"=as.numeric(Rsqu.lm),
"Training.RMSE.D"=as.numeric(RMSE.lm))
# } else {
#   testing.results <- rbind(testing.results,
#                            data.frame("Test.time"= test.index,
#                                 "Actual.forecast" = as.numeric(test.yy),
#                                 "LM.forecast" = as.numeric(pred.adapt),
#                                 "Persistence.forecast" = as.numeric(pred.persistence),
#                                 "Training.R2.LM" = as.numeric(Rsqu.adapt),
#                                 "Training.RMSE.LM" = as.numeric(RMSE.adapt),
#                                 "Diurnal.forecast" =as.numeric(pred.lm),
#                                 "Training.R2.D"=as.numeric(Rsqu.lm),
#                                 "Training.RMSE.D"=as.numeric(RMSE.lm)))
# }
# print(paste("Completed", obj, days, f, i,"in",(total.obs-2*f-training.obs+1)))
return(testing.results)
}))
all.horizons[[length(all.horizons)+1]] <- testing.results
print(paste("Completed", obj, days, f))
}
all.days[[length(all.days)+1]] <- all.horizons
}
assign(paste0("all.days.",obj), all.days)
save(list=paste0("all.days.",obj), file=paste0("results/all-days-",obj,".RData"))
rm(list=paste0("all.days.",obj))
}
}
library(glmnet)
start <- Sys.time()
for(obj in obj.list) {
obj.data <- get(obj)
predict.col <- which(colnames(obj.data) == "Z7.NH4")
if(paste0("all-days-",obj,".RData") %in% list.files(path="results/")) {
next
} else {
all.days <- list()
for(days in 1:6) {
# Days to train on
training.days <- days
training.obs <- training.days*24*60/5
total.obs <- nrow(obj.data)
testing.obs <- total.obs-training.obs
testing.days <- testing.obs/(24*60/5)
# What is the forecast horizon? (given in number of steps & number of minutes )
horizon.min <- seq(5,75,by=5)
horizon.steps <- horizon.min/5
all.horizons <- list()
for(f in horizon.steps) {
# for(i in 1:(total.obs-2*f-training.obs+1)) { # Faster to do this in an lapply loop
testing.results <- do.call("rbind", lapply(1:(total.obs-2*f-training.obs+1), function(i) {
# Setup training and testing data for model
current.obs <- training.obs+f+i-1
train.xx <- matrix(as.numeric(obj.data[i:(current.obs-f),]), nrow=length(i:(current.obs-f)), byrow=FALSE)
train.yy <- matrix(as.numeric(obj.data[(i+f):current.obs, predict.col]), nrow=length(i:(current.obs-f)), byrow=FALSE)
n <- intersect(which(!is.na(train.yy)), which(!apply(train.xx,1,anyNA)))
train.xx <- train.xx[n,]
train.yy <- train.yy[n,]
test.xx <- matrix(as.numeric(obj.data[current.obs,]), nrow=1, byrow=FALSE)
test.yy <- matrix(as.numeric(obj.data[(current.obs+f), predict.col]), nrow=1, byrow=FALSE)
test.index <- index(obj.data[current.obs,])
# Train diurnal model
diurnal.terms <- c(grep("cos", colnames(obj.data)), grep("sin", colnames(obj.data)))
mod.lm <- cv.glmnet(train.xx[,diurnal.terms],train.yy, alpha=0)
pred.lm <- predict(mod.lm, newx=train.xx[,diurnal.terms])
# Calculate training error
SSE <- mean((train.yy-pred.lm)^2)
SST <- mean((train.yy-mean(train.yy))^2)
Rsqu.lm <- 1-SSE/SST;Rsqu
RMSE.lm <- sqrt(SSE)
pred.lm <- predict(mod.lm, newx=t(test.xx[,diurnal.terms]))
# Train model when lambda=0 (initial parameter estimate)
mod.ridge <- cv.glmnet(train.xx,train.yy,alpha=0)
predict.mod.ridge <- predict(mod.ridge, newx=train.xx)
# # Plot training
# par(mar=c(3.5,3.5,1,10),xpd=TRUE, cex=0.9, family="serif")
# plot(train.yy,ylab="",xlab="", type="l", ylim=c(min(predict.mod.ridge),max(train.yy)))
# lines(predict.mod.ridge, col="red", lty=2)
# mtext(side=2, line=2.5, "Scaled Ammonia")
# mtext(side=1, line=2.5, "Observations (5 min interval)")
#
# legend("right",inset=c(-.5,0),
#        legend=c("Actual NH4","Linear Forecast\nw/ Sine Cosine"),
#        col=c("black","red"), lty=c(1,2) ,y.intersp=1.5)
# Adaptive lasso
w3 <- 1/abs(matrix(coef(mod.ridge, s=mod.ridge$lambda.min)[, 1][-1]))^1
set.seed(Sys.time())
mod.adaptive <- cv.glmnet(train.xx,train.yy,alpha=1,penalty.factor=w3)
pred.adapt <- predict(mod.adaptive,newx=train.xx, s='lambda.1se')
# Calculate training error
SSE <- mean((train.yy-pred.adapt)^2)
SST <- mean((train.yy-mean(train.yy))^2)
Rsqu.adapt <- 1-SSE/SST;Rsqu
RMSE.adapt <- sqrt(SSE)
SSE <- mean((train.yy-train.xx[,predict.col])^2)
Rsqu.persistence <- 1-SSE/SST;Rsqu
RMSE.persistence <- sqrt(SSE)
# Forecast
pred.adapt <- predict(mod.adaptive,newx=test.xx, s='lambda.1se')
pred.persistence <- test.xx[,predict.col]
# Save results
# if(i==1) {
testing.results <- data.frame("Test.time"= test.index,
"Actual.forecast" = as.numeric(test.yy),
"LM.forecast" = as.numeric(pred.adapt),
"Persistence.forecast" = as.numeric(pred.persistence),
"Training.R2.LM" = as.numeric(Rsqu.adapt),
"Training.RMSE.LM" = as.numeric(RMSE.adapt),
"Diurnal.forecast" =as.numeric(pred.lm),
"Training.R2.D"=as.numeric(Rsqu.lm),
"Training.RMSE.D"=as.numeric(RMSE.lm))
# } else {
#   testing.results <- rbind(testing.results,
#                            data.frame("Test.time"= test.index,
#                                 "Actual.forecast" = as.numeric(test.yy),
#                                 "LM.forecast" = as.numeric(pred.adapt),
#                                 "Persistence.forecast" = as.numeric(pred.persistence),
#                                 "Training.R2.LM" = as.numeric(Rsqu.adapt),
#                                 "Training.RMSE.LM" = as.numeric(RMSE.adapt),
#                                 "Diurnal.forecast" =as.numeric(pred.lm),
#                                 "Training.R2.D"=as.numeric(Rsqu.lm),
#                                 "Training.RMSE.D"=as.numeric(RMSE.lm)))
# }
# print(paste("Completed", obj, days, f, i,"in",(total.obs-2*f-training.obs+1)))
return(testing.results)
}))
all.horizons[[length(all.horizons)+1]] <- testing.results
print(paste("Completed", obj, days, f))
}
all.days[[length(all.days)+1]] <- all.horizons
}
assign(paste0("all.days.",obj), all.days)
save(list=paste0("all.days.",obj), file=paste0("results/all-days-",obj,".RData"))
rm(list=paste0("all.days.",obj))
}
}
end <- Sys.time()
end-start
obj.data <- get(obj)
predict.col <- which(colnames(obj.data) == "Z7.NH4")
numCores <- detectCores()
library(doParallel)
library(foreach)
# all.days <- list()
# for(days in 1:6) {
all.days <- foreach(days=1:6,
.combine = 'c', .packages = c("xts","stats","glmnet")) %dopar% {
# Days to train on
training.days <- days
training.obs <- training.days*24*60/5
total.obs <- nrow(obj.data)
testing.obs <- total.obs-training.obs
testing.days <- testing.obs/(24*60/5)
# What is the forecast horizon? (given in number of steps & number of minutes )
horizon.min <- seq(5,75,by=5)
horizon.steps <- horizon.min/5
all.horizons <- list()
for(f in horizon.steps) {
# for(i in 1:(total.obs-2*f-training.obs+1)) { # Faster to do this in an lapply loop
testing.results <- do.call("rbind", lapply(1:(total.obs-2*f-training.obs+1), function(i) {
# Setup training and testing data for model
current.obs <- training.obs+f+i-1
train.xx <- matrix(as.numeric(obj.data[i:(current.obs-f),]), nrow=length(i:(current.obs-f)), byrow=FALSE)
train.yy <- matrix(as.numeric(obj.data[(i+f):current.obs, predict.col]), nrow=length(i:(current.obs-f)), byrow=FALSE)
n <- intersect(which(!is.na(train.yy)), which(!apply(train.xx,1,anyNA)))
train.xx <- train.xx[n,]
train.yy <- train.yy[n,]
test.xx <- matrix(as.numeric(obj.data[current.obs,]), nrow=1, byrow=FALSE)
test.yy <- matrix(as.numeric(obj.data[(current.obs+f), predict.col]), nrow=1, byrow=FALSE)
test.index <- index(obj.data[current.obs,])
# Train diurnal model
diurnal.terms <- c(grep("cos", colnames(obj.data)), grep("sin", colnames(obj.data)))
mod.lm <- cv.glmnet(train.xx[,diurnal.terms],train.yy, alpha=0)
pred.lm <- predict(mod.lm, newx=train.xx[,diurnal.terms])
# Calculate training error
SSE <- mean((train.yy-pred.lm)^2)
SST <- mean((train.yy-mean(train.yy))^2)
Rsqu.lm <- 1-SSE/SST;Rsqu
RMSE.lm <- sqrt(SSE)
pred.lm <- predict(mod.lm, newx=t(test.xx[,diurnal.terms]))
# Train model when lambda=0 (initial parameter estimate)
mod.ridge <- cv.glmnet(train.xx,train.yy,alpha=0)
predict.mod.ridge <- predict(mod.ridge, newx=train.xx)
# # Plot training
# par(mar=c(3.5,3.5,1,10),xpd=TRUE, cex=0.9, family="serif")
# plot(train.yy,ylab="",xlab="", type="l", ylim=c(min(predict.mod.ridge),max(train.yy)))
# lines(predict.mod.ridge, col="red", lty=2)
# mtext(side=2, line=2.5, "Scaled Ammonia")
# mtext(side=1, line=2.5, "Observations (5 min interval)")
#
# legend("right",inset=c(-.5,0),
#        legend=c("Actual NH4","Linear Forecast\nw/ Sine Cosine"),
#        col=c("black","red"), lty=c(1,2) ,y.intersp=1.5)
# Adaptive lasso
w3 <- 1/abs(matrix(coef(mod.ridge, s=mod.ridge$lambda.min)[, 1][-1]))^1
set.seed(Sys.time())
mod.adaptive <- cv.glmnet(train.xx,train.yy,alpha=1,penalty.factor=w3)
pred.adapt <- predict(mod.adaptive,newx=train.xx, s='lambda.1se')
# Calculate training error
SSE <- mean((train.yy-pred.adapt)^2)
SST <- mean((train.yy-mean(train.yy))^2)
Rsqu.adapt <- 1-SSE/SST;Rsqu
RMSE.adapt <- sqrt(SSE)
SSE <- mean((train.yy-train.xx[,predict.col])^2)
Rsqu.persistence <- 1-SSE/SST;Rsqu
RMSE.persistence <- sqrt(SSE)
# Forecast
pred.adapt <- predict(mod.adaptive,newx=test.xx, s='lambda.1se')
pred.persistence <- test.xx[,predict.col]
# Save results
# if(i==1) {
testing.results <- data.frame("Test.time"= test.index,
"Actual.forecast" = as.numeric(test.yy),
"LM.forecast" = as.numeric(pred.adapt),
"Persistence.forecast" = as.numeric(pred.persistence),
"Training.R2.LM" = as.numeric(Rsqu.adapt),
"Training.RMSE.LM" = as.numeric(RMSE.adapt),
"Diurnal.forecast" =as.numeric(pred.lm),
"Training.R2.D"=as.numeric(Rsqu.lm),
"Training.RMSE.D"=as.numeric(RMSE.lm))
# } else {
#   testing.results <- rbind(testing.results,
#                            data.frame("Test.time"= test.index,
#                                 "Actual.forecast" = as.numeric(test.yy),
#                                 "LM.forecast" = as.numeric(pred.adapt),
#                                 "Persistence.forecast" = as.numeric(pred.persistence),
#                                 "Training.R2.LM" = as.numeric(Rsqu.adapt),
#                                 "Training.RMSE.LM" = as.numeric(RMSE.adapt),
#                                 "Diurnal.forecast" =as.numeric(pred.lm),
#                                 "Training.R2.D"=as.numeric(Rsqu.lm),
#                                 "Training.RMSE.D"=as.numeric(RMSE.lm)))
# }
# print(paste("Completed", obj, days, f, i,"in",(total.obs-2*f-training.obs+1)))
return(testing.results)
}))
all.horizons[[length(all.horizons)+1]] <- testing.results
print(paste("Completed", obj, days, f))
}
# all.days[[length(all.days)+1]] <- all.horizons
return(list(all.horizons))
}
library(glmnet)
library(doParallel)
library(foreach)
start <- Sys.time()
numCores <- detectCores()
registerDoParallel(numCores)
for(obj in obj.list) {
obj.data <- get(obj)
predict.col <- which(colnames(obj.data) == "Z7.NH4")
if(paste0("all-days-",obj,".RData") %in% list.files(path="results/")) {
next
} else {
# all.days <- list()
# for(days in 1:6) {
all.days <- foreach(days=1:6,
.combine = 'c', .packages = c("xts","stats","glmnet")) %dopar% {
# Days to train on
training.days <- days
training.obs <- training.days*24*60/5
total.obs <- nrow(obj.data)
testing.obs <- total.obs-training.obs
testing.days <- testing.obs/(24*60/5)
# What is the forecast horizon? (given in number of steps & number of minutes )
horizon.min <- seq(5,75,by=5)
horizon.steps <- horizon.min/5
all.horizons <- list()
for(f in horizon.steps) {
# for(i in 1:(total.obs-2*f-training.obs+1)) { # Faster to do this in an lapply loop
testing.results <- do.call("rbind", lapply(1:(total.obs-2*f-training.obs+1), function(i) {
# Setup training and testing data for model
current.obs <- training.obs+f+i-1
train.xx <- matrix(as.numeric(obj.data[i:(current.obs-f),]), nrow=length(i:(current.obs-f)), byrow=FALSE)
train.yy <- matrix(as.numeric(obj.data[(i+f):current.obs, predict.col]), nrow=length(i:(current.obs-f)), byrow=FALSE)
n <- intersect(which(!is.na(train.yy)), which(!apply(train.xx,1,anyNA)))
train.xx <- train.xx[n,]
train.yy <- train.yy[n,]
test.xx <- matrix(as.numeric(obj.data[current.obs,]), nrow=1, byrow=FALSE)
test.yy <- matrix(as.numeric(obj.data[(current.obs+f), predict.col]), nrow=1, byrow=FALSE)
test.index <- index(obj.data[current.obs,])
# Train diurnal model
diurnal.terms <- c(grep("cos", colnames(obj.data)), grep("sin", colnames(obj.data)))
mod.lm <- cv.glmnet(train.xx[,diurnal.terms],train.yy, alpha=0)
pred.lm <- predict(mod.lm, newx=train.xx[,diurnal.terms])
# Calculate training error
SSE <- mean((train.yy-pred.lm)^2)
SST <- mean((train.yy-mean(train.yy))^2)
Rsqu.lm <- 1-SSE/SST;Rsqu
RMSE.lm <- sqrt(SSE)
pred.lm <- predict(mod.lm, newx=t(test.xx[,diurnal.terms]))
# Train model when lambda=0 (initial parameter estimate)
mod.ridge <- cv.glmnet(train.xx,train.yy,alpha=0)
predict.mod.ridge <- predict(mod.ridge, newx=train.xx)
# # Plot training
# par(mar=c(3.5,3.5,1,10),xpd=TRUE, cex=0.9, family="serif")
# plot(train.yy,ylab="",xlab="", type="l", ylim=c(min(predict.mod.ridge),max(train.yy)))
# lines(predict.mod.ridge, col="red", lty=2)
# mtext(side=2, line=2.5, "Scaled Ammonia")
# mtext(side=1, line=2.5, "Observations (5 min interval)")
#
# legend("right",inset=c(-.5,0),
#        legend=c("Actual NH4","Linear Forecast\nw/ Sine Cosine"),
#        col=c("black","red"), lty=c(1,2) ,y.intersp=1.5)
# Adaptive lasso
w3 <- 1/abs(matrix(coef(mod.ridge, s=mod.ridge$lambda.min)[, 1][-1]))^1
set.seed(Sys.time())
mod.adaptive <- cv.glmnet(train.xx,train.yy,alpha=1,penalty.factor=w3)
pred.adapt <- predict(mod.adaptive,newx=train.xx, s='lambda.1se')
# Calculate training error
SSE <- mean((train.yy-pred.adapt)^2)
SST <- mean((train.yy-mean(train.yy))^2)
Rsqu.adapt <- 1-SSE/SST;Rsqu
RMSE.adapt <- sqrt(SSE)
SSE <- mean((train.yy-train.xx[,predict.col])^2)
Rsqu.persistence <- 1-SSE/SST;Rsqu
RMSE.persistence <- sqrt(SSE)
# Forecast
pred.adapt <- predict(mod.adaptive,newx=test.xx, s='lambda.1se')
pred.persistence <- test.xx[,predict.col]
# Save results
# if(i==1) {
testing.results <- data.frame("Test.time"= test.index,
"Actual.forecast" = as.numeric(test.yy),
"LM.forecast" = as.numeric(pred.adapt),
"Persistence.forecast" = as.numeric(pred.persistence),
"Training.R2.LM" = as.numeric(Rsqu.adapt),
"Training.RMSE.LM" = as.numeric(RMSE.adapt),
"Diurnal.forecast" =as.numeric(pred.lm),
"Training.R2.D"=as.numeric(Rsqu.lm),
"Training.RMSE.D"=as.numeric(RMSE.lm))
# } else {
#   testing.results <- rbind(testing.results,
#                            data.frame("Test.time"= test.index,
#                                 "Actual.forecast" = as.numeric(test.yy),
#                                 "LM.forecast" = as.numeric(pred.adapt),
#                                 "Persistence.forecast" = as.numeric(pred.persistence),
#                                 "Training.R2.LM" = as.numeric(Rsqu.adapt),
#                                 "Training.RMSE.LM" = as.numeric(RMSE.adapt),
#                                 "Diurnal.forecast" =as.numeric(pred.lm),
#                                 "Training.R2.D"=as.numeric(Rsqu.lm),
#                                 "Training.RMSE.D"=as.numeric(RMSE.lm)))
# }
# print(paste("Completed", obj, days, f, i,"in",(total.obs-2*f-training.obs+1)))
return(testing.results)
}))
all.horizons[[length(all.horizons)+1]] <- testing.results
print(paste("Completed", obj, days, f))
}
# all.days[[length(all.days)+1]] <- all.horizons
return(list(all.horizons))
}
assign(paste0("all.days.",obj), all.days)
save(list=paste0("all.days.",obj), file=paste0("results/all-days-",obj,".RData"))
rm(list=paste0("all.days.",obj))
}
}
end <- Sys.time()
end-start
