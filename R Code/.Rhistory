}
}
colnames(rmse.comparison) <- c("Training Window", "Forecast Horizon", "LM RMSE", "Persistence RMSE", "Model R2", "Persistence R2")
rmse.comparison.adapt <- rmse.comparison
# RMSE and R2 vs Forecast Horizon by Training Window (grouped plots)
line.colors <- rainbow(7)
mat <- matrix(c(1,2,3,4,4,5),2,3, byrow = TRUE)
layout(mat, widths=c(.35,.35,.3), heights = c(0.95,.05))
par(mar=c(3.5, 3.5, 0, .5) + 0.1, oma=c(0,0,0,0), cex=.9, family="serif")
# RMSE
# Diurnal+Linear By Training window
# x = forecast horizon, y = avg rmse for persistence model
plot(x=unique(rmse.comparison.adapt[,2]),
y=sapply(unique(rmse.comparison.adapt[,2]), function(x) mean(rmse.comparison.adapt[which(rmse.comparison.adapt[,2]==x),4])), type="l",
xlab="", ylab="", col="black", lwd=2, lty=2)
# x = forecast horizon, y =avg rmse for linear model/adaptive model
for(i in 1:length(unique(rmse.comparison.adapt[,1]))) {
lines(x=rmse.comparison.adapt[which(rmse.comparison.adapt[,1]==i),2],
y=rmse.comparison.adapt[which(rmse.comparison.adapt[,1]==i),3], type="l",
xlab="", ylab="", col=line.colors[i], lwd=2)
}
# Diurnal By Training window (single line)
# x = forecast horizon, y =avg rmse for diurnal model
for(i in 1:length(unique(rmse.comparison.adapt[,1]))) {
lines(x=rmse.comparison.lm[which(rmse.comparison.lm[,1]==i),2],
y=rmse.comparison.lm[which(rmse.comparison.lm[,1]==i),3], type="l",
xlab="", ylab="", col=line.colors[i], lwd=2, lty=3)
}
mtext("RMSE", side = 2, line = 2.5, outer=FALSE, adj=0.5)
# R2
# Diurnal+Linear By Training window
# x = forecast horizon, y = avg rmse for persistence model
plot(x=unique(rmse.comparison.adapt[,2]),
y=sapply(unique(rmse.comparison.adapt[,2]), function(x) mean(rmse.comparison.adapt[which(rmse.comparison.adapt[,2]==x),6])), type="l",
xlab="", ylab="", col="black", lwd=2, lty=2)
# x = forecast horizon, y =avg rmse for linear model/adaptive model
for(i in 1:length(unique(rmse.comparison.adapt[,1]))) {
lines(x=rmse.comparison.adapt[which(rmse.comparison.adapt[,1]==i),2],
y=rmse.comparison.adapt[which(rmse.comparison.adapt[,1]==i),5], type="l",
xlab="", ylab="", col=line.colors[i], lwd=2)
}
# Diurnal By Training window (single line)
# x = forecast horizon, y =avg rmse for diurnal model
for(i in 1:length(unique(rmse.comparison.adapt[,1]))) {
lines(x=rmse.comparison.lm[which(rmse.comparison.lm[,1]==i),2],
y=rmse.comparison.lm[which(rmse.comparison.lm[,1]==i),5], type="l",
xlab="", ylab="", col=line.colors[i], lwd=2, lty=3)
}
mtext("R-squared", side = 2, line = 2.5, outer=FALSE, adj=0.5)
# Legend
par(mar=c(0, 0, 0.1, 0))
plot(0, type="n", axes=FALSE, xlab="", ylab="", xlim=c(0, 10), ylim=c(0, 10))
legend("top",
legend=c("Persistence", "Diurnal", paste(unique(rmse.comparison.adapt[,1]), "day")),
col=c("black","red", line.colors), lty=c(2, 2, rep(1,7)), xpd = TRUE, title=names(all.days.files)[which(file==all.days.files)]
)
plot(0, type="n", axes=FALSE)
mtext("Forecast Horizon (min)")
plot(0, type="n", axes=FALSE)
}
all.days.files <- sapply(list.files("results/",pattern="all-days-"), function(x) load(paste0("results/",x), envir=.GlobalEnv))
all.days.files <- all.days.files[-4] # remove 300_plus
all.days.array <- array(data=NA, dim=c(length(all.days.files), 6,15))
for(file in all.days.files) {
all.days <- get(file)
for(days in 1:length(all.days)) {
obj.data <- all.days[[days]]
for(step in 1:length(obj.data)) {
results <- obj.data[[step]]
rmse.m <- sqrt(mean((results$LM.forecast-results$Actual.forecast)^2))
rmse.p <- sqrt(mean((results$Persistence.forecast-results$Actual.forecast)^2))
all.days.array[which(file==all.days.files),
days,
step] <- (rmse.p-rmse.m)/rmse.p*100
}
}
}
all.days.array.avg <- matrix(data=NA, nrow=dim(all.days.array)[2], ncol=dim(all.days.array)[3])
for(i in 1:dim(all.days.array)[2]) {
for(j in 1:dim(all.days.array)[3]) {
all.days.array.avg[i,j] <- mean(all.days.array[,i,j])
}
}
table.data <- data.frame(formatC(all.days.array.avg[,seq(1,ncol(all.days.array.avg),by=2)],digits=2))
rownames(table.data) <- paste(seq(1,6), "Day")
colnames(table.data) <- paste(seq(1,ncol(all.days.array.avg),by=2)*5, "Min")
kable(table.data)
library(doParallel)
library(foreach)
library(neuralnet)
numCores <- detectCores()
registerDoParallel(numCores)
# For testing code #
# obj <- obj.list[1]
# obj.data <- get(obj)
# predict.col <- which(colnames(obj.data) == "Z7.NH4")
# days <- 1
# For testing code #
start <- Sys.time()
print(start)
for(obj in obj.list[1:4]) {
obj.data <- get(obj)
predict.col <- which(colnames(obj.data) == "Z7.NH4")
if(paste0("all-days-nn-",obj,".RData") %in% list.files(path="results/")) {
next
} else {
# all.days <- foreach(days=1:6,
# .combine = 'c', .packages = c("xts","stats","neuralnet")) %dopar% {
all.days <- for(days in 1:6) {
# Days to train on
training.days <- days
training.obs <- training.days*24*60/5
total.obs <- nrow(obj.data)
testing.obs <- total.obs-training.obs
testing.days <- testing.obs/(24*60/5)
# What is the forecast horizon? (given in number of steps & number of minutes )
horizon.min <- seq(5,75,by=5)
horizon.steps <- horizon.min/5
all.horizons <- list()
for(f in horizon.steps) {
# for(i in 1:(total.obs-2*f-training.obs+1)) { # Faster to do this in an lapply loop
# testing.results <- do.call("rbind", lapply(1:(total.obs-2*f-training.obs+1), function(i) {
testing.results <- foreach(i=1:(total.obs-2*f-training.obs+1),
.combine = 'rbind', .errorhandling='remove', .packages = c("xts","stats","neuralnet")) %dopar% {
# Setup training and testing data for model
current.obs <- training.obs+f+i-1
train.xx <- matrix(as.numeric(obj.data[i:(current.obs-f),]), nrow=length(i:(current.obs-f)), byrow=FALSE)
train.yy <- matrix(as.numeric(obj.data[(i+f):current.obs, predict.col]), nrow=length(i:(current.obs-f)), byrow=FALSE)
n <- intersect(which(!is.na(train.yy)), which(!apply(train.xx,1,anyNA)))
train.xx <- train.xx[n,]
train.yy <- train.yy[n,]
test.xx <- matrix(as.numeric(obj.data[current.obs,]), nrow=1, byrow=FALSE)
test.yy <- matrix(as.numeric(obj.data[(current.obs+f), predict.col]), nrow=1, byrow=FALSE)
test.index <- index(obj.data[current.obs,])
# Train neural network model
diurnal.terms <- c(grep("cos", colnames(obj.data)), grep("sin", colnames(obj.data)))
nn.train.data <- cbind(train.yy, train.xx[,-diurnal.terms])
colnames(nn.train.data)[2:ncol(nn.train.data)] <- paste0("response.",1:ncol(train.xx[,-diurnal.terms]))
fmla <- as.formula(paste0("train.yy ~ ",
paste(paste0("response.",1:ncol(train.xx[,-diurnal.terms])),collapse=" + ")))
nn <- neuralnet(fmla, data=nn.train.data, hidden=3,
act.fct = "logistic",
linear.output = TRUE,
stepmax=1e+06)
nn.train.data <- train.xx[,-diurnal.terms]
colnames(nn.train.data) <- paste0("response.",1:ncol(train.xx[,-diurnal.terms]))
pred.nn <- compute(nn, nn.train.data)
pred.nn <- pred.nn$net.result
# Calculate neural network error
SSE <- mean((train.yy-pred.nn)^2)
SST <- mean((train.yy-mean(train.yy))^2)
Rsqu.nn <- 1-SSE/SST
RMSE.nn <- sqrt(SSE)
# Forecast neural network
nn.test.data <- matrix(test.xx[,-diurnal.terms], nrow=1)
colnames(nn.test.data) <- paste0("response.",1:length(test.xx[,-diurnal.terms]))
pred.nn <- compute(nn, nn.test.data)
pred.nn <- pred.nn$net.result
testing.results <- data.frame("Test.time"= test.index,
"Actual.forecast" = as.numeric(test.yy),
"NN.forecast" = as.numeric(pred.nn),
"Training.R2.NN" = as.numeric(Rsqu.nn),
"Training.RMSE.NN" = as.numeric(RMSE.nn))
return(testing.results)
# if(i==1) all.results <- testing.results
# if(i>1) all.results <- rbind(all.results, testing.results)
}
# ))
all.horizons[[length(all.horizons)+1]] <- testing.results
# all.horizons[[length(all.horizons)+1]] <- all.results
print(paste("Completed", obj, days, f))
}
all.days[[length(all.days)+1]] <- all.horizons
# return(list(all.horizons))
}
if(length(all.days) < 6) {
print(paste("Error on", obj))
}
assign(paste0("all.days.nn.",obj), all.days)
save(list=paste0("all.days.nn.",obj), file=paste0("results/all-days-nn-",obj,".RData"))
rm(list=paste0("all.days.nn.",obj))
}
}
load("C:/Users/R-Compiler/Documents/KNewhart/LIFT_2019/R Code/results/all-days-nn-ab3_do.RData")
all.days.nn.ab3_do
stopImplicitCluster()
library(doParallel)
library(foreach)
library(neuralnet)
numCores <- detectCores()
registerDoParallel(numCores)
# For testing code #
# obj <- obj.list[1]
# obj.data <- get(obj)
# predict.col <- which(colnames(obj.data) == "Z7.NH4")
# days <- 1
# For testing code #
start <- Sys.time()
print(start)
obj<-obj.list[1]
# for(obj in obj.list[1:4]) {
obj.data <- get(obj)
predict.col <- which(colnames(obj.data) == "Z7.NH4")
# if(paste0("all-days-nn-",obj,".RData") %in% list.files(path="results/")) {
#   next
# } else {
# all.days <- foreach(days=1:6,
# .combine = 'c', .packages = c("xts","stats","neuralnet")) %dopar% {
# all.days <- for(days in 1:6) {
days <- 1
# Days to train on
training.days <- days
training.obs <- training.days*24*60/5
total.obs <- nrow(obj.data)
testing.obs <- total.obs-training.obs
testing.days <- testing.obs/(24*60/5)
# What is the forecast horizon? (given in number of steps & number of minutes )
horizon.min <- seq(5,75,by=5)
horizon.steps <- horizon.min/5
all.horizons <- list()
for(f in horizon.steps) {
# for(i in 1:(total.obs-2*f-training.obs+1)) { # Faster to do this in an lapply loop
# testing.results <- do.call("rbind", lapply(1:(total.obs-2*f-training.obs+1), function(i) {
testing.results <- foreach(i=1:(total.obs-2*f-training.obs+1),
.combine = 'rbind', .errorhandling='remove', .packages = c("xts","stats","neuralnet")) %dopar% {
# Setup training and testing data for model
current.obs <- training.obs+f+i-1
train.xx <- matrix(as.numeric(obj.data[i:(current.obs-f),]), nrow=length(i:(current.obs-f)), byrow=FALSE)
train.yy <- matrix(as.numeric(obj.data[(i+f):current.obs, predict.col]), nrow=length(i:(current.obs-f)), byrow=FALSE)
n <- intersect(which(!is.na(train.yy)), which(!apply(train.xx,1,anyNA)))
train.xx <- train.xx[n,]
train.yy <- train.yy[n,]
test.xx <- matrix(as.numeric(obj.data[current.obs,]), nrow=1, byrow=FALSE)
test.yy <- matrix(as.numeric(obj.data[(current.obs+f), predict.col]), nrow=1, byrow=FALSE)
test.index <- index(obj.data[current.obs,])
# Train neural network model
diurnal.terms <- c(grep("cos", colnames(obj.data)), grep("sin", colnames(obj.data)))
nn.train.data <- cbind(train.yy, train.xx[,-diurnal.terms])
colnames(nn.train.data)[2:ncol(nn.train.data)] <- paste0("response.",1:ncol(train.xx[,-diurnal.terms]))
fmla <- as.formula(paste0("train.yy ~ ",
paste(paste0("response.",1:ncol(train.xx[,-diurnal.terms])),collapse=" + ")))
nn <- neuralnet(fmla, data=nn.train.data, hidden=3,
act.fct = "logistic",
linear.output = TRUE,
stepmax=1e+06)
nn.train.data <- train.xx[,-diurnal.terms]
colnames(nn.train.data) <- paste0("response.",1:ncol(train.xx[,-diurnal.terms]))
pred.nn <- compute(nn, nn.train.data)
pred.nn <- pred.nn$net.result
# Calculate neural network error
SSE <- mean((train.yy-pred.nn)^2)
SST <- mean((train.yy-mean(train.yy))^2)
Rsqu.nn <- 1-SSE/SST
RMSE.nn <- sqrt(SSE)
# Forecast neural network
nn.test.data <- matrix(test.xx[,-diurnal.terms], nrow=1)
colnames(nn.test.data) <- paste0("response.",1:length(test.xx[,-diurnal.terms]))
pred.nn <- compute(nn, nn.test.data)
pred.nn <- pred.nn$net.result
testing.results <- data.frame("Test.time"= test.index,
"Actual.forecast" = as.numeric(test.yy),
"NN.forecast" = as.numeric(pred.nn),
"Training.R2.NN" = as.numeric(Rsqu.nn),
"Training.RMSE.NN" = as.numeric(RMSE.nn))
return(testing.results)
# if(i==1) all.results <- testing.results
# if(i>1) all.results <- rbind(all.results, testing.results)
}
# ))
all.horizons[[length(all.horizons)+1]] <- testing.results
# all.horizons[[length(all.horizons)+1]] <- all.results
print(paste("Completed", obj, days, f))
# }
all.days[[length(all.days)+1]] <- all.horizons
# return(list(all.horizons))
}
# if(length(all.days) < 6) {
#   print(paste("Error on", obj))
# }
# assign(paste0("all.days.nn.",obj), all.days)
# save(list=paste0("all.days.nn.",obj), file=paste0("results/all-days-nn-",obj,".RData"))
# rm(list=paste0("all.days.nn.",obj))
# }
# }
end <- Sys.time()
end-start
stopImplicitCluster()
library(doParallel)
library(foreach)
library(neuralnet)
numCores <- detectCores()
registerDoParallel(numCores)
# For testing code #
# obj <- obj.list[1]
# obj.data <- get(obj)
# predict.col <- which(colnames(obj.data) == "Z7.NH4")
# days <- 1
# For testing code #
start <- Sys.time()
print(start)
obj<-obj.list[1]
# for(obj in obj.list[1:4]) {
obj.data <- get(obj)
predict.col <- which(colnames(obj.data) == "Z7.NH4")
# if(paste0("all-days-nn-",obj,".RData") %in% list.files(path="results/")) {
#   next
# } else {
# all.days <- foreach(days=1:6,
# .combine = 'c', .packages = c("xts","stats","neuralnet")) %dopar% {
# all.days <- for(days in 1:6) {
days <- 1
# Days to train on
training.days <- days
training.obs <- training.days*24*60/5
total.obs <- nrow(obj.data)
testing.obs <- total.obs-training.obs
testing.days <- testing.obs/(24*60/5)
# What is the forecast horizon? (given in number of steps & number of minutes )
horizon.min <- seq(5,75,by=5)
horizon.steps <- horizon.min/5
all.horizons <- list()
for(f in horizon.steps) {
# for(i in 1:(total.obs-2*f-training.obs+1)) { # Faster to do this in an lapply loop
# testing.results <- do.call("rbind", lapply(1:(total.obs-2*f-training.obs+1), function(i) {
testing.results <- foreach(i=1:(total.obs-2*f-training.obs+1),
.combine = 'rbind', .errorhandling='remove', .packages = c("xts","stats","neuralnet")) %dopar% {
# Setup training and testing data for model
current.obs <- training.obs+f+i-1
train.xx <- matrix(as.numeric(obj.data[i:(current.obs-f),]), nrow=length(i:(current.obs-f)), byrow=FALSE)
train.yy <- matrix(as.numeric(obj.data[(i+f):current.obs, predict.col]), nrow=length(i:(current.obs-f)), byrow=FALSE)
n <- intersect(which(!is.na(train.yy)), which(!apply(train.xx,1,anyNA)))
train.xx <- train.xx[n,]
train.yy <- train.yy[n,]
test.xx <- matrix(as.numeric(obj.data[current.obs,]), nrow=1, byrow=FALSE)
test.yy <- matrix(as.numeric(obj.data[(current.obs+f), predict.col]), nrow=1, byrow=FALSE)
test.index <- index(obj.data[current.obs,])
# Train neural network model
diurnal.terms <- c(grep("cos", colnames(obj.data)), grep("sin", colnames(obj.data)))
nn.train.data <- cbind(train.yy, train.xx[,-diurnal.terms])
colnames(nn.train.data)[2:ncol(nn.train.data)] <- paste0("response.",1:ncol(train.xx[,-diurnal.terms]))
fmla <- as.formula(paste0("train.yy ~ ",
paste(paste0("response.",1:ncol(train.xx[,-diurnal.terms])),collapse=" + ")))
nn <- neuralnet(fmla, data=nn.train.data, hidden=3,
act.fct = "logistic",
linear.output = TRUE,
stepmax=1e+06)
nn.train.data <- train.xx[,-diurnal.terms]
colnames(nn.train.data) <- paste0("response.",1:ncol(train.xx[,-diurnal.terms]))
pred.nn <- compute(nn, nn.train.data)
pred.nn <- pred.nn$net.result
# Calculate neural network error
SSE <- mean((train.yy-pred.nn)^2)
SST <- mean((train.yy-mean(train.yy))^2)
Rsqu.nn <- 1-SSE/SST
RMSE.nn <- sqrt(SSE)
# Forecast neural network
nn.test.data <- matrix(test.xx[,-diurnal.terms], nrow=1)
colnames(nn.test.data) <- paste0("response.",1:length(test.xx[,-diurnal.terms]))
pred.nn <- compute(nn, nn.test.data)
pred.nn <- pred.nn$net.result
testing.results <- data.frame("Test.time"= test.index,
"Actual.forecast" = as.numeric(test.yy),
"NN.forecast" = as.numeric(pred.nn),
"Training.R2.NN" = as.numeric(Rsqu.nn),
"Training.RMSE.NN" = as.numeric(RMSE.nn))
return(testing.results)
# if(i==1) all.results <- testing.results
# if(i>1) all.results <- rbind(all.results, testing.results)
}
# ))
all.horizons[[length(all.horizons)+1]] <- testing.results
# all.horizons[[length(all.horizons)+1]] <- all.results
print(paste("Completed", obj, days, f))
# }
all.days[[length(all.days)+1]] <- all.horizons
# return(list(all.horizons))
}
# if(length(all.days) < 6) {
#   print(paste("Error on", obj))
# }
# assign(paste0("all.days.nn.",obj), all.days)
# save(list=paste0("all.days.nn.",obj), file=paste0("results/all-days-nn-",obj,".RData"))
# rm(list=paste0("all.days.nn.",obj))
# }
# }
end <- Sys.time()
end-start
str(all.horizons)
names(all.horizons) <- seq(5,75,by=5)
str(all.horizons)
paste("results/nn",obj,collapse="/")
paste("results/nn",obj,collapse="//")
file.path(paste0("results/nn/",obj))
paste0("results/nn/",obj)
paste0("results/nn/",obj,"/",paste0(obj,"_",days,"_",f,".RData"))
paste0("results/nn/",paste0(obj,"_",days,"_",f,".RData"))
save(all.horizons, file=paste0("results/nn/",paste0(obj,"_",days,"_",f,".RData")))
save(all.horizons, file=paste0("results/nn/",paste0("nn_",obj,"_",days".RData")))
save(all.horizons, file=paste0("results/nn/",paste0("nn_",obj,"_",days,".RData")))
save(all.horizons, file=paste0("results/nn/",paste0("nn_",obj,"_",days,"d.RData")))
str(all.horizons)
save(all.horizons, file=paste0("results/nn/",paste0("nn_",obj,"_",days,"d.RData")))
list.files(path="results/nn")
list.files(path="results/nn/")
getwd()
setwd("KNewhart\\LIFT_2019\\R Code\\results\\nn")
setwd(..)
setwd("..")
setwd("..")
list.files(path="results/nn/")
paste0("results/nn/",paste0("nn_",obj,"_",days,"d.RData")) %in% list.files(path="results/nn/")
paste0("nn_",obj,"_",days,"d.RData") %in% list.files(path="results/nn/")
stopImplicitCluster()
library(doParallel)
library(foreach)
library(neuralnet)
numCores <- detectCores()
registerDoParallel(numCores)
# For testing code #
# obj <- obj.list[1]
# obj.data <- get(obj)
# predict.col <- which(colnames(obj.data) == "Z7.NH4")
# days <- 1
# For testing code #
start <- Sys.time()
print(start)
dir.create(paste0("results/nn"), showWarnings = FALSE)
for(obj in obj.list[1:4]) {
obj.data <- get(obj)
predict.col <- which(colnames(obj.data) == "Z7.NH4")
# if(paste0("all-days-nn-",obj,".RData") %in% list.files(path="results/")) {
#   next
# } else {
# all.days <- foreach(days=1:6,
# .combine = 'c', .packages = c("xts","stats","neuralnet")) %dopar% {
for(days in 1:6) {
if(paste0("nn_",obj,"_",days,"d.RData") %in% list.files(path="results/nn/")) next
# Days to train on
training.days <- days
training.obs <- training.days*24*60/5
total.obs <- nrow(obj.data)
testing.obs <- total.obs-training.obs
testing.days <- testing.obs/(24*60/5)
# What is the forecast horizon? (given in number of steps & number of minutes )
horizon.min <- seq(5,75,by=5)
horizon.steps <- horizon.min/5
all.horizons <- list()
for(f in horizon.steps) {
# for(i in 1:(total.obs-2*f-training.obs+1)) { # Faster to do this in an lapply loop
# testing.results <- do.call("rbind", lapply(1:(total.obs-2*f-training.obs+1), function(i) {
testing.results <- foreach(i=1:(total.obs-2*f-training.obs+1),
.combine = 'rbind', .errorhandling='remove', .packages = c("xts","stats","neuralnet")) %dopar% {
# Setup training and testing data for model
current.obs <- training.obs+f+i-1
train.xx <- matrix(as.numeric(obj.data[i:(current.obs-f),]), nrow=length(i:(current.obs-f)), byrow=FALSE)
train.yy <- matrix(as.numeric(obj.data[(i+f):current.obs, predict.col]), nrow=length(i:(current.obs-f)), byrow=FALSE)
n <- intersect(which(!is.na(train.yy)), which(!apply(train.xx,1,anyNA)))
train.xx <- train.xx[n,]
train.yy <- train.yy[n,]
test.xx <- matrix(as.numeric(obj.data[current.obs,]), nrow=1, byrow=FALSE)
test.yy <- matrix(as.numeric(obj.data[(current.obs+f), predict.col]), nrow=1, byrow=FALSE)
test.index <- index(obj.data[current.obs,])
# Train neural network model
diurnal.terms <- c(grep("cos", colnames(obj.data)), grep("sin", colnames(obj.data)))
nn.train.data <- cbind(train.yy, train.xx[,-diurnal.terms])
colnames(nn.train.data)[2:ncol(nn.train.data)] <- paste0("response.",1:ncol(train.xx[,-diurnal.terms]))
fmla <- as.formula(paste0("train.yy ~ ",
paste(paste0("response.",1:ncol(train.xx[,-diurnal.terms])),collapse=" + ")))
nn <- neuralnet(fmla, data=nn.train.data, hidden=3,
act.fct = "logistic",
linear.output = TRUE,
stepmax=1e+06)
nn.train.data <- train.xx[,-diurnal.terms]
colnames(nn.train.data) <- paste0("response.",1:ncol(train.xx[,-diurnal.terms]))
pred.nn <- compute(nn, nn.train.data)
pred.nn <- pred.nn$net.result
# Calculate neural network error
SSE <- mean((train.yy-pred.nn)^2)
SST <- mean((train.yy-mean(train.yy))^2)
Rsqu.nn <- 1-SSE/SST
RMSE.nn <- sqrt(SSE)
# Forecast neural network
nn.test.data <- matrix(test.xx[,-diurnal.terms], nrow=1)
colnames(nn.test.data) <- paste0("response.",1:length(test.xx[,-diurnal.terms]))
pred.nn <- compute(nn, nn.test.data)
pred.nn <- pred.nn$net.result
testing.results <- data.frame("Test.time"= test.index,
"Actual.forecast" = as.numeric(test.yy),
"NN.forecast" = as.numeric(pred.nn),
"Training.R2.NN" = as.numeric(Rsqu.nn),
"Training.RMSE.NN" = as.numeric(RMSE.nn))
return(testing.results)
# if(i==1) all.results <- testing.results
# if(i>1) all.results <- rbind(all.results, testing.results)
}
# ))
all.horizons[[length(all.horizons)+1]] <- testing.results
# all.horizons[[length(all.horizons)+1]] <- all.results
print(paste("Completed", obj, days, f, Sys.time()))
}
# return(list(all.horizons))
names(all.horizons) <- seq(5,75,by=5)
save(all.horizons, file=paste0("results/nn/",paste0("nn_",obj,"_",days,"d.RData")))
rm(all.horizons)
}
# if(length(all.days) < 6) {
#   print(paste("Error on", obj))
# }
# assign(paste0("all.days.nn.",obj), all.days)
# save(list=paste0("all.days.nn.",obj), file=paste0("results/all-days-nn-",obj,".RData"))
# rm(list=paste0("all.days.nn.",obj))
}
